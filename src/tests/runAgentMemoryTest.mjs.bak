/**
 * Standalone test runner for Agent Memory functionality
 * This script provides a more comprehensive test of the agent memory system
 * 
 * Run with: node --experimental-modules src/tests/runAgentMemoryTest.mjs
 */

import { initializeApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';

// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyBsHoAvguKeV8XnT6EkV2Q0hyAv6OEw8bo",
  authDomain: "codesignagent-f4420.firebaseapp.com",
  databaseURL: "https://codesignagent-f4420-default-rtdb.firebaseio.com",
  projectId: "codesignagent-f4420",
  storageBucket: "codesignagent-f4420.firebasestorage.app",
  messagingSenderId: "121164910498",
  appId: "1:121164910498:web:552f246dc0a3f28792ecfb",
  measurementId: "G-YKVCSPS593"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Since we can't directly import the services (they use imports without extensions),
// we'll implement the minimal functionality needed for the test here
import { collection, addDoc, getDocs, query, where, orderBy, limit } from 'firebase/firestore';

// Memory types supported
const MemoryTypes = ['short_term', 'long_term', 'conversation', 'reflection'];

// Collection name for agent memories
const MEMORY_COLLECTION = 'AgentMemory';

/**
 * Store a memory in Firestore
 */
async function storeMemory(content, type, metadata = {}) {
  console.log(`Storing memory: "${content.substring(0, 50)}${content.length > 50 ? '...' : ''}"`);
  
  const memoryData = {
    title: `Memory: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}`,
    content,
    type,
    tags: [`memory_${type}`],
    timestamp: new Date(),
    // Simple mock embedding for testing
    embedding: Array(10).fill(0).map(() => Math.random()),
    metadata: {
      memoryType: type,
      createdAt: new Date().toISOString(),
      ...metadata
    }
  };
  
  const memoryCollection = collection(db, MEMORY_COLLECTION);
  const docRef = await addDoc(memoryCollection, memoryData);
  console.log(`‚úì Memory stored with ID: ${docRef.id}`);
  
  return docRef.id;
}

/**
 * Get memories of a specific type
 */
async function getMemoriesByType(type, maxResults = 10) {
  console.log(`Retrieving ${type} memories...`);
  
  const memoryCollection = collection(db, MEMORY_COLLECTION);
  
  try {
    // Try with orderBy first (requires index)
    const memoryQuery = query(
      memoryCollection,
      where('type', '==', type),
      orderBy('timestamp', 'desc'),
      limit(maxResults)
    );
    
    const querySnapshot = await getDocs(memoryQuery);
    
    const memories = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      memories.push({
        id: doc.id,
        content: data.content,
        type,
        timestamp: data.timestamp,
        tags: data.tags,
        metadata: data.metadata
      });
    });
    
    console.log(`‚úì Retrieved ${memories.length} ${type} memories`);
    return memories;
  } catch (error) {
    // If we get an index error, fall back to simpler query
    console.log('Error with ordered query, falling back to simple query:', error.message);
    
    // Simpler query without orderBy
    const simpleQuery = query(
      memoryCollection,
      where('type', '==', type)
    );
    
    const querySnapshot = await getDocs(simpleQuery);
    
    const memories = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      memories.push({
        id: doc.id,
        content: data.content,
        type,
        timestamp: data.timestamp,
        tags: data.tags,
        metadata: data.metadata
      });
    });
    
    // Sort in memory
    memories.sort((a, b) => {
      // Handle various timestamp formats
      const getTimestampMs = (timestamp) => {
        if (timestamp instanceof Date) {
          return timestamp.getTime();
        } else if (typeof timestamp === 'object' && timestamp !== null) {
          // Handle Firestore Timestamp
          if ('seconds' in timestamp) {
            return timestamp.seconds * 1000;
          }
        }
        // Default value if timestamp is invalid
        return 0;
      };
      
      const timeA = getTimestampMs(a.timestamp);
      const timeB = getTimestampMs(b.timestamp);
      
      return timeB - timeA; // Descending order (newest first)
    });
    
    // Apply limit after sorting
    const limitedMemories = memories.slice(0, maxResults);
    
    console.log(`‚úì Retrieved ${limitedMemories.length} ${type} memories (in-memory sort)`);
    return limitedMemories;
  }
}

/**
 * Retrieve memories relevant to a specific context
 */
async function getRelevantMemories(context, maxResults = 5) {
  console.log(`Retrieving memories relevant to: "${context.substring(0, 50)}${context.length > 50 ? '...' : ''}"`);
  
  // Get all memories
  const memoryCollection = collection(db, MEMORY_COLLECTION);
  const querySnapshot = await getDocs(memoryCollection);
  
  const memories = [];
  querySnapshot.forEach((doc) => {
    const data = doc.data();
    // Skip documents with missing content
    if (!data.content) {
      console.log(`Skipping document ${doc.id} - missing content property`);
      return;
    }
    memories.push({
      id: doc.id,
      content: data.content,
      type: data.type || 'unknown',
      timestamp: data.timestamp,
      tags: data.tags || [],
      metadata: data.metadata || {}
    });
  });
  
  // Primitive "similarity" - check if memory contains any words from the context
  const keywords = context.toLowerCase().split(/\s+/).filter(w => w.length > 3);
  
  const scoredMemories = memories.map(memory => {
    const text = memory.content.toLowerCase();
    let score = 0;
    
    keywords.forEach(keyword => {
      if (text.includes(keyword)) score += 1;
    });
    
    return { memory, score };
  });
  
  // Sort and limit results
  const relevantMemories = scoredMemories
    .sort((a, b) => b.score - a.score)
    .slice(0, maxResults)
    .filter(item => item.score > 0)
    .map(item => item.memory);
  
  console.log(`‚úì Found ${relevantMemories.length} relevant memories`);
  return relevantMemories;
}

/**
 * Comprehensive test of Agent Memory functionality
 */
async function runAgentMemoryTest() {
  console.log('üß† COMPREHENSIVE AGENT MEMORY TEST');
  console.log('===================================');
  
  // Track test results
  const results = {
    storedMemories: [],
    retrievedMemories: [],
    searchResults: []
  };
  
  try {
    // PHASE 1: Store various memory types
    console.log('\nüìù PHASE 1: STORING DIFFERENT MEMORY TYPES');
    console.log('-----------------------------------');
    
    // Create a simulated conversation history
    const conversationMemories = [
      "User asked: What makes a problem 'wicked' in design thinking?",
      "Agent responded: Wicked problems are complex, interconnected issues without clear solutions.",
      "User asked: Can you provide examples of wicked problems?",
      "Agent responded: Climate change, poverty, and healthcare are classic examples of wicked problems.",
      "User asked: How do designers approach wicked problems?",
      "Agent responded: Designers use systems thinking, iterative approaches, and collaborative methods."
    ];
    
    console.log(`Storing ${conversationMemories.length} conversation memories...`);
    
    // Store each conversation turn
    const conversationIds = [];
    for (const [index, memory] of conversationMemories.entries()) {
      const id = await storeMemory(
        memory,
        "conversation",
        {
          turnIndex: index,
          sessionId: "test-session-" + Date.now(),
          timestamp: new Date(Date.now() - (5 - index) * 60000) // Spread out by minutes
        }
      );
      conversationIds.push(id);
      results.storedMemories.push({ id, type: "conversation", content: memory });
    }
    
    console.log(`‚úÖ Stored ${conversationIds.length} conversation memories`);
    
    // Store some reflection memories
    console.log('\nStoring reflection memories...');
    const reflections = [
      "The user seems particularly interested in design methodology for complex social problems.",
      "I should provide more concrete examples and actionable frameworks when discussing wicked problems.",
      "The user's questions suggest they might be working on a project with many stakeholders and constraints."
    ];
    
    const reflectionIds = [];
    for (const reflection of reflections) {
      const id = await storeMemory(
        reflection,
        "reflection",
        {
          confidence: 0.85,
          actionable: true
        }
      );
      reflectionIds.push(id);
      results.storedMemories.push({ id, type: "reflection", content: reflection });
    }
    
    console.log(`‚úÖ Stored ${reflectionIds.length} reflection memories`);
    
    // Store a long-term memory about the user
    console.log('\nStoring long-term user memory...');
    const longTermId = await storeMemory(
      "This user consistently engages with topics related to systems thinking, design methodology, and social impact.",
      "long_term",
      {
        importance: "high",
        category: "user_interests",
        lastUpdated: new Date()
      }
    );
    results.storedMemories.push({ 
      id: longTermId, 
      type: "long_term", 
      content: "This user consistently engages with topics related to systems thinking, design methodology, and social impact." 
    });
    
    console.log(`‚úÖ Stored long-term memory with ID: ${longTermId}`);
    
    // PHASE 2: Retrieve memories by type
    console.log('\nüîç PHASE 2: RETRIEVING MEMORIES BY TYPE');
    console.log('-----------------------------------');
    
    // Get conversation history
    console.log('\nRetrieving conversation history...');
    const retrievedConversations = await getMemoriesByType("conversation", 10);
    console.log(`‚úÖ Retrieved ${retrievedConversations.length} conversation memories`);
    
    // Display a few conversation memories
    if (retrievedConversations.length > 0) {
      console.log('\nLatest conversation turns:');
      retrievedConversations.slice(0, 3).forEach((memory, i) => {
        console.log(`